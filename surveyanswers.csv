How many years of experience do you have with programming puppet?;If you had to judge a piece of puppet code (file or module) on its quality, what would you look for?;Could you give some examples of bad practices in puppet code?;What aspects do you take into account when selecting a puppet module from GitHub or Puppet Forge?;"<strong>How do you decide what <span style=""font-size: 12pt;"">goes</span> into Hiera and what doesn’t?</strong>";What is your biggest problem when programming puppet?Response;Open-Ended Response;Open-Ended Response;Open-Ended Response;Open-Ended Response;Open-Ended ResponseLess than one year;"To judge a piece of puppet code, I'd start looking for how many ""exec"" command there are and if they could be replaced by a better alternative.";As I commented at point #2, a bad practise consists on using exec commands instead of the right syntax. The exec command must be used only if there is no other alternative.;I take into account:  - If it is an official module  - If it is updated frequently  - If it works as it should do  - If it's a clean piece of code or not;I haven't needed to use Hiera until now.;The biggest problem you find when you starts is how to use modules written by other ones, but once you get experience and you use one of them successfully it's easy.3 - 4 years;Adherence to the Puppet Style Guide, documentation, resource relationships;Not adhering to the Puppet style guide.  Not organized - e.g. lack of abstraction, too much abstraction.  Current best practices.;"Same as what I mentioned in the ""judge a piece of puppet code on quality.""  Documented.  Author's reputation.  Module completeness, tests.";What data is differentiated based on some variable (e.g. datacenter, environment).  Don't make Hiera a DSL for the Puppet DSL - e.g. try not to declare resources in Hiera.;3 - 4 years;consistent formatting, simplicity, and an absolute minimum of exec statements.;declaring classes outside of site.pp/nodes.pp/ENC. Using execs where standard resources would suffice. Only testing modules for eventual consistency instead of first-run consistency.;number of downloads, author, puppet supported, simple interface, and supports my platform.;class parameters, variables that are different between hosts, secrets (passwords & api keys), and complex data structures go in hiera.;poor data discovery mechanisms. I want to be able to put exec output in a variable.1 - 2 years;Documentation, compliance with common conventions and programming practices, evidence of testing on at least one non-Linux platform, evidence that the person who wrote the module actually understood the underlying design and functionality of the service, rather than merely encapsulating their one specific use case;Hard-coded defaults for operating-system-specific values, path names, service names, etc.  Failure to use the hiera-module-data pattern when it would be clearly appropriate.;Whether it's clear from the documentation that the author understood cross-platform programming and the underlying service itself sufficiently that using the module would be significantly less work than writing our own.;Any literal value (string, numeric, or boolean) that plausibly varies from one node to another, such that the variation is adequately captured without inordinate levels of repetition by Hiera's data model should go into Hiera.;"Module composition is made unnecessarily difficult by the ""once and only once"" resource instantiation rules.  It should be possible to instantiate resources multiple times and have provider-specific code handle merging them into a single instance when possible.    The error messages are pretty awful.    The DSL has too many gratuitous differences from Ruby syntax.    Lots of things that ought to be standard, aren't, making it difficult to write truly portable and reusable modules even when one is aware of the underlying issues."3 - 4 years;Tests + CI integration;Huge monolithic blobs for configuring nodes and networks in just one file! It starts off harmless but ends up a real pain over time.;Stargazers, tests, recent updates;Not explicit atm.;It's custom DSL and tricky dependency resolution.3 - 4 years;custom types, not so many execs;5 execs to do something , or run again still changes something or give some output;popular or not;everything which is host specific, and not global or environment;understanding the modules , what it does? , always need to look at the code instead of the readme3 - 4 years;Readability, adherence to style guides, appropriate organization of code into classes and modules, use of a params class, separation of data from code, sparing and responsible use of exec resources, good comments and documentation, good test coverage. See also: https://forge.puppetlabs.com/approved/criteria;Mixture of site specific data into code, overuse of the exec resource, use of puppet 4 parser language functions such as iteration when it is unnecessary and reduces readability;I generally use heuristics that keep me from selecting modules based on code. I will speak with our operations team to find which modules we're already using for similar applications (and I work at Puppet, so I imagine their taste in modules is generally good!). If I can't go by what we're already using, I will generally make a selection based puppet supported or approved criteria.;Anything site-specific should go into Hiera. If you gave your code to a different organization, what would they have to change to get it to work? Put that in Hiera.;Forgetting commas! :)1 - 2 years;"Documentation and how the classes are laid out (ie. install/config/service classes; if there's a params.pp for OS-specific data; how much external dependencies the module needs, both in terms of other modules and whether it assumes URLs for packages or package repos set up beforehand; whether the module wants to manage some other piece of software to support the software it sets up and if it lets you choose whether it manages the extra software (ie. module for a web app managing Apache for you and not giving you the option to disable it, as you may be using another Apache Puppet module already).";"Excessive usage of exec resources; use of chaining arrows on multiple resources that refresh or notify the same downstream resource (the notifying resources should be contained in a class and the entire class refreshes the downstream resource or class); not using a params.pp for OS-specific data";Whether it's been recently updated, has documentation and has CentOS/Debian/Ubuntu OS support;"Company or organization specific data goes into Hiera; OS or platform specific data generally does not (it's easier and makes modules more portable if these are in a params.pp)";Lack of details from the Puppet master and agent when Ruby-based errors occur, especially with types/providers.1 - 2 years;In order of importance: Focus. Smoke tests. Documentation.;;In order of importance: Date of last commit. Number of open issues. Number of stars. Number of forks.;Data goes in Hiera. Code goes in Puppet.;Testing, testing, testing.More than 5 years;"""Lint"" type items, like aligning arrows, indicate an attention to detail that I like.  It should be idempotent.  Extra points if it's well commented.";Using an exec resource where a native type would have done the job just as well.  Hardcoding variables, when a class/type parameter could have been used.;How long it's been since the most recent update.  How many other projects the author has.  Whether multiple authors are collaborating to make it better.;I imagine I'm going to share my module with others, and anything that I'd have to redact because it's specific to my business belongs in Hiera, not code.;"Typos are the bane of my programming existence and are about half of the ""puppet problems"" I have."More than 5 years;Linting / style is a quick first glance indicator of quality. After that, what kinds of resources are used. Specifically, execs are used frequently in poor quality Puppet code, and infrequently (though still occasionally) in good Puppet code.;Using exec resources to shell out to custom scripts unnecessarily. Bad indentation. Non-idempotent code. Failure to use params.pp or Hiera when appropriate. Lots of static variables set in code when they should be set as class parameters.;The Forge has good automatic + community metrics. Simultaneously scoring high on both usually indicates pretty good quality. On Github, having a README that conforms to standard practices and is detailed in the module usage is a good indicator. Finally, an active project (recent commits) is something I try to select for when choosing between multiple projects.;"Business-specific data should go in Hiera, and optimizations or optional adjustments away from a generic baseline configuration. A class should usually ""just work"" when using something like ""include <classname>"". Data necessary to make it work should be included as defaults, data that is adjusting for a non-generic use case should be in Hiera.";Debugging can sometimes be difficult. Usually I resort to printf-style debugging by inserting notify resources in the manifest.3 - 4 years;the guidelines on the forge on which it judges the code are fairly good, but sometimes deceiving.    style is important to me.  support of up-to-date test-tooling, as well support of up-to-date versions of puppet  tests  good docs;"tabs, unaligned hash-rockets and assignments. it just makes code hard to read if you're used to the code as documented in the style-guide.    use of inherit  use of if / else over selectors  use of if-elsif-else over case  use of if to capsule logic paths, rather than classes / defines  hand-compiling a piece of software…  use of ""manual wget"", rather than puppet-archive  complex execs rather than a type ;)";availability on the forge. i don't look on github before i didn't look on forge.  if there's none that are supported or approved, i look for the ones with the highest scores and read their docs first to find out if they have any… and if they have what i need it to do.  if the docs are inconclusive, i read the source code…  actually, scratch that, i almost always read the source code.;that's simple: everything    the only things i encode in profiles are our very custom ways of setting up $software (if any).;This answer was removed from the public dataset since it was not anonymous.1 - 2 years;complete test cases and code coverage  clever code structure (like plugable, central basic functions)  helpful documentation (using guide, readme);- missing dependencies (-> or ~>)  - code with a lot of exec's and if / else closures  - using augeas at all;- actively maintained module?  - puppet module interface and documentation of the interface;- What should be customer / server location dependent?  - ssh-authorized-keys are always handled with hiera, cause I / we use the same hiera for all git branches  ;writing good test cases on non low-hanging-fruits code partsMore than 5 years;First adherence to the Puppet community style guide. Most modern code is written this way and it's an easy way to eliminate ancient code.    Next I'll look at the structure. Is it broken into reasonable parts. Install in one spot, config in another, etc. Use of config dirs, included defines for injecting new config files, etc are all good signs.    After that how does it attempt to solve the problem. I'm concerned about whether the writer actually understands the daemon their attempting to manage. May also look for missing functionality at this point.    Finally look at the parameters and how easy it will be to extend. Generally I'm not a fan of paramaterized modules that try to handle every case. Usually it needs to be ripped out and replaced with a simple options => $hash, that can send arbitrary tuning where it needs to go.;Quoted booleans    Empty strings as undef. example class blah( $some_var = ' ',) { if $somevar == ' ' {}}    Hardcoded values that don't follow the distro paths    Compiling gems, packages, etc when reasonable versions are in common repos. example puppetlabs-passenger    if { if { if { if , aka a sign it all needs to be moved into Hiera.    $var = hiera(blah)  if $var == 'NONE' {    $real_var = 'somevalue'  }    ;99% of modules in the forge or on Github are a waste of time. The only modules I'm interested in are the ones that include a type and provider. An example is puppetlabs-mysql. The part of the module that manages Mysql is overwrought and parts were definitely written by people who didn't understand Mysql or manage data layers. Something better and simpler could be written in an hour. However the user accounts and grants part is pretty decent. In our system we forked the module and dropped everything but the grants part. Then wrote our own simpler module with sane defaults. ;Module defaults go into the module.  System defaults go into the profile  Everything else goes into Hiera.     It's usually more complicated than that, but those are decent guidelines. ;Thinking through the design. Usually takes 2-3 tries to get something that works and is flexible enough for the future. Try not to worry too much about generalizing the first time around.     Sometimes the problem is working around Puppet's declared state. It's a complete pain in the ass when you want to change mounts and need to manage state through the run. 1 - 2 years;The amount and quality of its unit and acceptance tests.;"Lots of exec resources.  Lack of unit/acceptance tests.  ""Swiss army knife"" utility vs a focused utility";Suitability to personal requirements.  Quality of tests.  Perceived ability to contribute fixes.;Everything that can be site-specific should be available via hiera (usually through automatic parameter lookups) with sane defaults when it makes sense, so users do not need to fill hiera with boilerplate.;Identifying the state model I desire before writing any code.3 - 4 years;Adherence to the Puppet Style Guide.  Lint checks.  Spec tests, if they exist.  Readability.;Unnecessary exec{} resources.  Lack of examples in documentation.  Insufficient comments.  ;Number of downloads.  Frequency of releases.  Responsiveness to tickets opened.  ;Business data.  Data that is different by application environment or data center.  Data that we want developers to be able to change.;Writing spec tests is laborious, and poorly documented. I'd like to write more (and better) tests, but I don't fully understand how to be successful.1 - 2 years;Usually, code that is good can be judged based on it's testing code coverage. Puppet is interesting because it is still very new, hence even good modules may not have full code coverage. Also Puppet's use case is usually to provision and manage configuration. Hence, programmers and engineers do not necessarily have the resources, drive, or motivation to write as many tests - their puppet code is most likely NOT their bread-and-butter. This doesn't mean that the code isn't good code.    I find that the best puppet modules are ones that have these traits:    - had design thoroughly thought out  - Projects that follow the Puppetlabs convention - https://docs.puppetlabs.com/guides/best_practices.html  - Modules or projects that remain flexible, even when versions of apps or sources change frequently.  ;Overly convoluted code. Not making use of variables.  ;Commit activity, contributors and the number of forks on a project.;The decision is simple - should the variable be a secret? Ultimately, this comes down to experience.    An experienced programmer will know what can be kept a secret and what cannot.    Examples:  - private SSH keys  - Private URLS  - API tokens;We don't have many problems. The biggest problem we've run into is relying on a third-party module from puppet forge or puppet-labs.    We've eventually had to either:  - make forks of some modules to include some of the features we need (or fix a bug)  - switch to another module1 - 2 years;class structure and logical resource separation. In example code dealing with configuration separated from installation.;1. logical branching on environment depended variables in the class  2. single class shabang  3. overdriven resource ordering  4. hardcoded assumptions ;1. Number of downloads  2. Last update  3. Available parameters  4. Known author;Mostly I look for lower level modules, so no hiera relation. Data driven decisions are made in higher level modules like profiles.;Puppet 3:  1. lack of loops  2. type validation  3. resource ordering    Puppet 4:  .ack of ruby block More than 5 years;linting and testing. Yet this will all be dependent on how well tests are built.;no I could not. In the recent years we've seen two new major versions of puppet, and multiple best practices guides appear. These are now updated frequently and getting hard to keep track of.  Maintaining modules on the puppet forge takes a lot more time than I first expected. ;is the documentation exhaustive? and does it mention my use case? has the module recently been updated?;pretty much all of your variables should be stored in a central place - hiera, foreman, ldap, servicenow or whatever. If you manage large environments I believe this is mandatory.;Writing custom functions in ruby, as I don't have a lot of ruby expertise.3 - 4 years;Documentation, parameterization, uniform applicability across platforms, and userbase ;Not placing platform-specific code inside of a platform check, hard-coding for a particular use case instead of abstracting specifics;Install-base (or downloads), number of commits and contributors in github;Yeah, good question, right? We've recently switched to using Hiera-eyaml-gpg (https://github.com/sihil/hiera-eyaml-gpg) so we could theoretically put anything in a blob and put it in.     In practice, I find myself writing wrapper modules specific to my infrastructure whenever I need to deploy a set of files (for instance, I have a service that allows for (and requires) a free-form configuration section that I provide in a file. I run many instances of this service, so I have a wrapper module for this puppet module, and I store the per-server files in the wrapper module). ;Trying to order puppet code so that requirements are met in a satisfactory order on the first application. More than 5 years;Parameter instantiation in a controlled manner and manifest class usage that doesn't leak start-stop anchors.;Negate the above. Don't use hiera for parameter instantiation in production. Overly scripted with ruby.;Rate of maintenance, code quality in github repo, who made it, what version it is, is it for my OS and how many people seem to be using it?;Non-default parameter values go into hiera. Configuration state go in puppetdb. ;"Testing puppet properly and ensuring changes did not break production. Directly after that; controlled deployment of puppet manifests. After that, controlled/staged/orchestration of app deploys using puppet."1 - 2 years;syntax, readablitiy;one liners, to much use of exec;development on the module, open issues;data => hiera, infra => puppet;seperation what is data and what is infra1 - 2 years;* Data being retrieved from external sources (i.e. parameters)  * classes being declared with as few parameters as possible (allowing for parameter modification through an external parameter source such as hiera);* Hardcoded data (such as user names) in puppet manifests  * Complicated fallback logic divining a variable from multiple differently named parameters  *  Setting default paramaters for resources other modules use (e.g. setting a default search path for the exec resource)  * parametrizing third-party modules/classes with explicit in-code values that are not controlled through the declaring class' parameters (this way parametrizing the third-party class in question differently becomes impossible without modifying the offending code);* Modularity/loose coupling: Can I easily take a subset of the module's classes and work with it or is the module's init.pp the only way to realistically use it?  * Easy parametrization: Everything I could conceivably want to  modify is a parameter so I do not have to fork the module and/or submit a patch for such things.;All variable data (user names, file and directory names,  etc.) goes into Hiera. Where it makes sense a class may contain sensible defaults for parameters or even logic for computing a value in the absence of a parameter.;Working around upstream modules that modify and/or declare classes or resources outside their scope (worst case example: a module that declares  class { apache: } with a long list of static in-code parameters).1 - 2 years;Good use of variables (particularly those that make parts of a module optional) and clear concise code that is easy to read. Also good documentation is very important.;Poor or non-existent documentation. Code with lots of hard coded value.;Last time it was updated & authors responsiveness to issues and pull requests.;Hiera is for business data, usernames, passwords anything that will always be specific to your environment.;Snowflake servers. They require some create hacking usually involving a LOT of Hiera data that maybe shouldn't be there at all.3 - 4 years;Formatting, if they use exec, usage of a standard structure, tests.;Usage of exec (I try to minimize execs). Putting all code in one class. ;Number of forks, primarily.;For our use case, we decided to move all parameters that we update frequently to hiera. Also, we keep here all parameters/classes that are different based on location, organization, os release, etc.;No problems that I can think of.More than 5 years;Documentation, unit tests (using rspec-puppet), abstraction of data from code (at minimum, use of parameterized classes with defaults in a foo::params class, but better to use something like the module-data module and keep class defaults in Hiera), conformity to the Puppet Labs style guide, use of custom types/providers/facts where appropriate instead of overuse of Exec resources, use of common third-party modules (stdlib, augeas_providers);failure to validate inputs to parameterized classes, non-reversible resources (e.g. using an Exec to create a file, but not providing any way to remove that file), program logic in templates (use of branching statements);Is the module Puppet Labs supported or approved?  Does the module pass its unit tests on the first try?  Is the documentation thorough?  Does it support the osfamily I need?  Was it written by an author I recognize?;Once I discovered R. I. Pienaar's module-data, I started putting all of my default values in Hiera. Any value that I explicitly don't want the user to be able to override (computed values, or values where there is only one correct answer) go in code, everything else in Hiera.;Detection and resolution of dependency loopsMore than 5 years;travis-ci tests;data in code;Author, tests, scope    http://sysadvent.blogspot.fr/2015/12/day-11-5-years-of-puppet-experience.html;REAL DATA goes in hiera  OS specific stuff don't;no problemsMore than 5 years;"API/match/mapping with managed software; ease of use; coverage of use-cases; consistency; programming style; test coverage; documentation; factoring of code (DRY, SRP, etc)";* hiera lookups in business logic  * cross-class dependencies  * dependencies on parameterised titles;https://forge.puppetlabs.com/approved/criteria;n/a;understanding/modelling underlying software1 - 2 years;Good docs, recent updates (puppet 4 and future parser support a huge plus), extensibility (clean function interface, exposure of key facts);No usage tests, not using implicit hiera lookups. Excessive requirements on external modules. Incorrect manifest.json. ;Frequency of updates, responses to outstanding issues, quality of documentation, license m;Anything that a user would change at runtime goes in hiera;Lack of clear errors / tracebacks for runtime errors (much improved in puppet 4, but can still be improved)1 - 2 years;Simplicity, flexibility, rspec tests and with very few hardcoded dependencies on other modules.;A module that wants to micromanage beyond it's scope (firewall rules, networking, logrotation).    It's nice that it wants to do that, but at the very least those should all be optional.;See #2    Active development and feedbacks also makes it more attracting.;Distro specific stuff should be taken care of through the params paradigm.    In theory you should be able to just include the module in the manifest and then set all the important stuff in hiera if it can be considered as data.;rspec test are an afterthought and issues are usually fixed by trial and error.    In the short term that's ok for a consultant which needs to get the job done fast for a customer.    But in the long run you can't test this in different scenario's because you aren't able to test them consistently1 - 2 years;"* contains any test    * no need to catch coverage - better high level tests instead of testing all details and duplicating the module itself)    * usage of other modules for some tasks (database, alternatives, ...) - less copying of the code and better reuse    * exec usage: prefer other constructs instead (although execs doesn't necessary mean bad code)    * sometimes custom functions or facts in the ruby are better    * do not call classes with parameters inside the code    * (it is OK to be called this way for ""internal"" classes though)    * (it is OK in the examples or roles)    * module is available at the puppet forge";* not documenting usage of the module    * forcing users to use specific puppet feature (direct hiera calls, inventory is hard to setup, ...);"* usable and well documented (doesn't need to have simple usage, if there are examples)    * if it works rather quickly without much fights and experimenting    * if there are more options what to do with it (custom variables to apache configurations, custom properties for tomcat, ...)    * interesting features (for example JDBC installation in puppetlabs MySQL/PostgreSQL, mysqltuner script installation, ...)    * quick look to the code (for example adrien/alternatives module is awesome: just four ruby files providing all resources needed)    * official puppeptlabs modules have slightly higher priority    * if there are NOT incorporated too many things (hardcoded java installation of specific version/implementation, database installation, ...); This goes partially against the recommended best practices saying ""module should be as self-contained as possible"". :-)    * some recent release (<= two years?), some recent commits (<= one year?)";* I don't distinguish much between class parameters and hiera, so for me it is more question what to parametrize and what do not    * more parameters for low-level modules (package name, ensure parameter for services, ...)    * OS specific defaults doesn't need to be always parametrized (but low-level modules would need that too - they may be used in non-standard platforms, ...);"* limitation on the single node: I would need some whole-cluster-wait for something before continuing the setup, or whole-cluster setup stages    * repeating parameters in all public classes: I'm rather using no-operation main configuration class instead (I guest the recommended best practice is to use only the main class for everything?)    * multiple installation of the same package is problematic (I'm trying to use ensure_package() from stdlib module as workaround)    * package ensure parameter:    * I don't care if the package is 'held' or 'installed' (puppet requires the exact state)    * 'held' can't be combined with the version    * stability of puppet language: they sometimes literally change false to true (testing for undef or empty string is the nightmare ;-))    * distribution of the puppet itself: the new packaging incorporate even java and ruby, which shuld go from the OS instead (but it is more about puppet itself, not about programming)"1 - 2 years;Cleanness, expandability, code conventions, testing;Reinvent the wheel.;Cleanness, expandability, code conventions, testing;Things that changes goes into Hiera.;The biggest issue is the lack of best practices for the toolset.1 - 2 years;Whether it actually works ... hard to tell unless you try it.;Poor implementation, e.g. unreliable, lack of configurability.;"Coming from ""official"" source, date last updated, compatible puppet version, documentation.";Good question.;Non-determinism, impurity, poor quality modules, complexity induced by cross-platform support  (I only want Linux), changes in the syntax and api, puppet syntax is weird and ugly, pretty poor api documentation (e.g. types documentation), module distribution, use of ruby, it's slow to apply changes, much more...Less than one year;Efficient use of variables, proper care of flow if modules are interdependent, documentation.;1. Not keeping check of dependent modules (those which needs to be executed first than others).  2. Redundant code doing same things.  3. Too many classes.;The quality of module, feedback from people/web/blogs about different modules and the support available.;If something is confidential (password/users/keys), we generally put it in hiera since hiera is not kept with code and never committed upstream.  If a variable needs to be passed at multiple locations and we want to change its value for one specific instance, we try to overwrite the default value by specifying it in hiera rather than passing everywhere.;Documentation examples. Online documentation does tell about the functionality, but lacks examples.3 - 4 years;"length (number of lines)  ""colors"" of code in my IDE (to see if there are lots of hard coded texts in the code, or if variable are used  variables provided for the ""class""  check if create_resources is used (if used, much more concise code)  ...";Trying to be compatible with all the OSes, because it lead often to high complexity;If possible, I do not use puppet module. Lots of them are very poor quality, and try to be compatible with lots of operating system, which is not a need for me (and for lots of us), because, often, we try to choose a platform stack (debian, ...) and have all of our servers installed with this stack. In this case, this is not really useful to be compatible with other stacks/os, and difficult to be optimized with all.;"By answering the question : ""If I use this class for an other customer/project, do I need to update it or is it ready yet just using configuration via Hiera""";order of execution  time of execution if you do not take of reducing the number of modulesMore than 5 years;Consistency and integration points, the ability to extend the module with on-site specific code without changing the module itself, a good example is the example42 module base as it provides all the required knobs to fit them perfectly onto a specific on-site infrastructure while promoting re usability and non intrusive features;mots modules provided by puppetlabs as they are to opinionated for real life usage ;integration and extendability, is there an optional integration point provided for firewalling / selinux / monitoring ? are the basics done ? are the required features supported ?;"everything thats pure ""data"" should go into hiera, only complicated structures should go into puppet code, for example if you need to make decisions based on multiple facts if a resource is generated or not";"error reporting and validation of code / data in a multi dc, multi continent setup which tend to get complicated where quickly. validation is the biggest pain point here, especially when you are also doing a fair share of hiera cross lookups, tools like kwalify can help you here but are not ""there yet"""More than 5 years;Module/file organisation, linting, behaviour;Not allowing to disable management of repositories or other parts that could be handled by other modules, preventing interoperability between modules from multiple providers;Code quality/cleanness, number of stars and forks, activity, documentation...;"Has much as posssible, everything that is ""configuration"" either targetting all the infrastructure or  only one part";multiple incompatible modules of different quality. No clear good practice/standard on module organisation (like things like params.pp and other patterns)3 - 4 years;puppet-lint compliant, puppet validated to be sure it functions and if it meets the PCS pattern of Ken Barber: http://www.slideshare.net/PuppetLabs/modern-module-development-ken-barber-2012-edinburgh-puppet-camp;Not following the PCS pattern for starters, not using default values of parameters, enforcing people to use for example managed_repos by setting it default to true (should be false by default) using explicit hiera calls! and therefore forcing people to use hiera;meets PCS have sane default params;data -> hiera;deciding roles/profiles/hiera data3 - 4 years;Documentation and Unittests. Also for the supported platforms. How modular it was build. ;Simple puppet that just changes a single thing without any possibility of change. ;How simple I can integrate it into a existing environment. It should be possible without a change to the existing environment.;"I'm not using hiera yet ;( ";Out-date code in a legacy environment. As well the problem of puppet not able to handle to complex setup (ceph problem)Less than one year;I would think structuring. If they are using classes correctly. If they are using native puppet functions rather than trying to do things using command line commands.   ;Most ;I haven't yet. ;I don't;If you're setting up cron jobs, it's impossible to actually test what puppet does. Also, I've had times where puppet has added new cronjobs, but not removed old ones - the issue happens when you change the name of a cronjob. More than 5 years;parsing puppetlint .. readability, modularity ;failing at lint ,  no use of modules , hardcoding params,  no use of subclasses,  no use of profiles,   lack of upstream modules in the tree,  failing to have a pipeline for the code ;support for Distros, modularity , use of OS packages ,  ;sane defaults vs configuratble data,   ;3 - 4 years;- number of exec resources  - number of if statements  - number of class declarations by 'class resource'  - number of 'vampire features' used (i.e. obscure features that generally are hardly used, '+>' operator is an example)  - usage of custom types  - reliance on resource defaults  - usage of metaparameters ('require', etc)  - usage of third party modules  ;"- exec resources without 'stop condition'; they trigger a modification action on each puppet run  - class declarations as a resource, where 'include' would have been sufficient";- time since latest release (not too old)  - puppet forge quality rating (although admitted that doesn't say a lot)  - author (I trust some others more than others, 'puppetlabs' for example)  - if the actual code is still on github  - if all parameters are documented  - how many downloads the module has (more is better)  - I usually quickly skim through the code to get a feel for if it would fit in our codebase;Data that is likely to be modified during its lifetime goes in hiera. Data that is not likely to be modified is ok to put in puppet.;writing modules for applications that don't lend themselves too well for puppetizing. For example, some applications don't offer command-line configuration (i.e. you're expected to do configuration in a browser - this hard if not impossible to puppetize).